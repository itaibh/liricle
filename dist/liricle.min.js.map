{"version":3,"file":"liricle.min.js","sources":["../src/parser.js","../src/sync.js","../src/liricle.js"],"sourcesContent":["// will match: \"[name:value]\"\nconst TAGS_REGEX = /\\[([a-z]+):(.+)\\]/i;\n\n// will match: \"[00:00.00]\" one or more.\nconst TIME_REGEX = /\\[\\d{2}:\\d{2}(.\\d{2,})?\\]{1,}/g;\n\n// will match: \"<00:00.00> blablabla\".\nconst WORD_REGEX = /(<\\d{2}:\\d{2}.\\d{2,}>\\s{0,}([^\\s]+))/g;\n\n// only match: \"<00:00.00>\". mainly used to extract time.\nconst WORD_TIME_REGEX = /<\\d{2}:\\d{2}(.\\d{2,})?>/;\n\nconst output = {\n      lines: [],\n      tags: {},\n      enhanced: false,\n};\n\nlet wordIndex = 0;\n\n/**\n * LRC parser\n * @param {string} lrc - LRC text\n * @returns {Object} output\n */\nfunction parser(lrc) {\n      // check if the lrc file is enhanced or not\n      if (WORD_TIME_REGEX.test(lrc)) {\n            output.enhanced = true;\n      }\n\n      const lines = lrc.split(/\\r|\\n/);\n\n      // parsing started\n      lines.forEach((line) => {\n            parseTags(line);\n            parseLine(line);\n      });\n\n      output.lines = sortLines(output.lines);\n      return output;\n}\n\n/**\n * parse tags data from LRC file\n * @param {string} line - LRC line\n */\nfunction parseTags(line) {\n      const match = line.match(TAGS_REGEX);\n\n      if (match == null) return;\n\n      const name = match[1];\n      const value = match[2].trim();\n\n      // push data to output\n      output.tags[name] = value;\n}\n\n/**\n * parse line from LRC file\n * @param {string} line - LRC line\n */\nfunction parseLine(line) {\n      const match = line.match(TIME_REGEX);\n\n      if (match == null) return;\n\n      match.forEach((value) => {\n            // push data to output\n            output.lines.push({\n                  time: convertTime(value),\n                  text: extractText(line),\n                  words: parseWords(line)\n            });\n      });\n}\n\n/**\n * parse words from enhanced LRC\n * @param {string} line - LRC line\n * @returns {Array} parsed words\n */\nfunction parseWords(line) {\n      const match = line.match(WORD_REGEX);\n      const words = [];\n\n      if (match == null) return null;\n\n      match.forEach((value) => {\n            // extract timestamp. \"<00:00.00>\"\n            // i think it's easier than split them.\n            const time = value.match(WORD_TIME_REGEX)[0];\n\n            words.push({\n                  index: wordIndex,\n                  time: convertTime(time),\n                  text: extractText(value),\n            });\n            \n            wordIndex += 1;\n      });\n\n      return words;\n}\n\n/**\n * extract text / lyric from timed line\n * @param {string} line - LRC line\n * @returns {string} extracted text\n */\n function extractText(line) {\n      // remove timestamp\n      line = line.replace(TIME_REGEX, \"\");\n      line = line.replace(WORD_REGEX, \"$2\");\n\n      return line.trim();\n}\n\n/**\n * convert \"[03:24.73]\" => 204.73 (total time in seconds)\n * @param {string} time - string time \"[mm:ss.xx]\" or \"<mm:ss.xx>\"\n * @returns {number} total time in seconds\n */\nfunction convertTime(time) {\n      time = time.replace(/\\[|\\]|<|>/g, \"\");\n      time = time.split(\":\");\n\n      let [min, sec] = time;\n\n      min = parseInt(min) * 60;\n      sec = parseFloat(sec);\n\n      return min + sec;\n}\n\n/**\n * sort lines from shortest to longest\n * @param {Array} lines - parsed lines\n * @returns {Array} sorted lines\n */\nfunction sortLines(lines) {\n      return lines.sort((a, b) => a.time - b.time);\n}\n\nexport default parser;\n","/**\n * find closest lyric index from given time\n * @param {Object} data - output data from parser\n * @param {number} time - currrent time from audio player or something in seconds\n * @returns {Object} - the current lyric line and word\n */\nfunction sync(data, time) {\n      let line = findLine(data, time);\n      let word = line != null && data.enhanced ? findWord(line, time) : null;\n\n      // delete words property from line\n      if (line != null) delete line.words;\n\n      return { line, word };\n}\n\n/**\n * find closest line\n * @param {Object} data \n * @param {number} time - currrent time\n * @returns {Object|null}\n */\nfunction findLine(data, time) {\n      const lines = data.lines;\n      const index = getClosestIndex(lines, time);\n\n      return index != null ? { index, ...lines[index] } : null;\n}\n\n/**\n * find closest word\n * @param {Object} line \n * @param {number} time - currrent time\n * @returns {Object|null}\n */\nfunction findWord(line, time) {\n      const words = line.words;\n      const index = getClosestIndex(words, time);\n\n      return index != null ? words[index] : null;\n}\n\n/**\n * find closest lyric index\n * @param {Array} data \n * @param {number} time - currrent time \n * @returns {number|null} index of lyric\n */\nfunction getClosestIndex(data, time) {\n      // to find the closest index we just need to subtract each line or word time with the given time\n      // then put the value into an array and find the smallest positive value with Math.min()\n      // after that we can find the index from smallest value in array with indexOf() method.\n\n      const scores = [];\n\n      data.forEach((item) => {\n            const score = time - item.time;\n            if (score >= 0) scores.push(score);\n      });\n\n      if (scores.length == 0) return null;\n\n      const smallest = Math.min(...scores);\n      const index = scores.indexOf(smallest);\n\n      return index;\n}\n\nexport default sync;\n","import parser from \"./parser.js\";\nimport sync from \"./sync.js\";\n\nclass Liricle {\n      constructor() {\n            this._activeLine = null;\n            this._onInit = () => {};\n            this._onSync = () => {};\n\n            this.data = null;\n      }\n\n      /**\n       * \n       * @param {*} param0 \n       */\n      async init({ text, url }) {\n            let lrc = text;\n\n            if (url) {\n                  try {\n                        const resp = await fetch(url);\n                        const body = await resp.text();\n\n                        lrc = body;\n                  } \n                  \n                  catch (error) { throw Error(error) }\n            }\n\n            this.data = parser(lrc);\n            this._onInit(this.data);\n      }\n\n      /**\n       * \n       * @param {*} time \n       * @param {*} offset \n       */\n      sync(time, offset = 0) {\n            const { line, word } = sync(this.data, time + offset);\n\n            // if not enhanced, event update only occurs if it \n            // reaches the next lyric instead of updating every second.\n            if (!this.data.enhanced) {\n                  if (line.index == null ||\n                      line.index == this._activeLine\n                  ) return;\n\n                  this._activeLine = line.index;\n                  return this._onSync(line, word);\n            }\n\n            // simplify, i think it's not good if there are too many parameters.\n            this._onSync(line, word);\n      }\n\n      /**\n       * \n       * @param {*} event \n       * @param {*} callback \n       */\n      on(event, callback) {\n            if (typeof callback != \"function\") {\n                  throw Error(\"callback must be a function!\");\n            }\n\n            switch (event) {\n                  case \"init\":\n                        this._onInit = callback;\n                        break;\n                  case \"sync\":\n                        this._onSync = callback;\n                        break;\n            }\n      }\n}\n\nexport default Liricle;\n"],"names":["TAGS_REGEX","TIME_REGEX","WORD_REGEX","WORD_TIME_REGEX","output","lines","tags","enhanced","wordIndex","parser","lrc","test","split","forEach","line","match","name","value","trim","parseTags","push","time","convertTime","text","extractText","words","parseWords","parseLine","sort","a","b","sortLines","index","replace","min","sec","parseInt","parseFloat","sync","data","getClosestIndex","findLine","word","findWord","scores","item","score","length","smallest","Math","indexOf","constructor","this","_activeLine","_onInit","_onSync","async","url","resp","fetch","error","Error","offset","on","event","callback"],"mappings":"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"}