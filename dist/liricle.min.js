/*!
 * liricle v2.1.0
 * mini library to run & sync lrc file
 * https://github.com/mcanam/liricle#readme
 * MIT license by mcanam
 */
var t,n;t=this,n=function(){"use strict";const t=/\[([a-z]+):(.+)\]/i,n=/\[\d{2}:\d{2}(.\d{2,})?\]{1,}/g;function i(i){let e={},o=[];function c(t){t=(t=t.replace(/\[|\]/g,"")).split(":");let[n,i]=t;return n=60*parseInt(n),i=parseFloat(i),n+i}function s(t){return(t=t.replace(n,"")).trim()}return i.split(/\r|\n/).forEach((i=>{!function(n){const i=n.match(t);if(null==i)return;const o=i[1],c=i[2];e[o]=c}(i),function(t){const i=t.match(n);null!=i&&i.forEach((n=>{o.push({time:c(n),text:s(t)})}))}(i)})),{info:e,data:function(t){return t.sort(((t,n)=>t.time-n.time))}(o)}}return class{constructor(){this._activeLine=null,this._onInit=()=>{},this._onSync=()=>{},this.info={},this.data=[]}async init({text:t,url:n}){let e=t;if(n)try{const t=await fetch(n);e=await t.text()}catch(t){throw Error(t)}const{info:o,data:c}=i(e);this.info=o,this.data=c,this._onInit(o,c)}sync(t,n=0){const i=function(t,n){const i=[];if(t.forEach((t=>{const e=n-t.time;e>=0&&i.push(e)})),0==i.length)return null;const e=Math.min(...i);return i.indexOf(e)}(this.data,t+n);if(null==i)return;if(i==this._activeLine)return;const{text:e}=this.data[i];this._activeLine=i,this._onSync(i,e)}on(t,n){if("function"!=typeof n)throw Error("callback must be a function!");switch(t){case"init":this._onInit=n;break;case"sync":this._onSync=n}}}},"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(t="undefined"!=typeof globalThis?globalThis:t||self).Liricle=n();
