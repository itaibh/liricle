/*!
 * liricle v2.0.1
 * mini library to run & sync lrc file
 * https://github.com/mcanam/liricle#readme
 * MIT license by mcanam
 */
var t,i;t=this,i=function(){"use strict";return class{constructor(){this._onInit=()=>{},this._onSync=()=>{},this._info={},this._data=[],this._activeLine=null}async init({text:t,url:i}){let e="";if(t)e=t;else{if(!i)throw Error("Missing parameter. You can pass text or url from lrc file.");e=await this._loadLyric(i)}this._parseLyric(e),this._onInit(this._info,this._data)}sync(t,i=0){const e=this._findLineIndex(t+i);if(null==e)return;if(e==this._activeLine)return;const n=this._data[e].text;this._activeLine=e,this._onSync(e,n)}on(t,i){if("function"!=typeof i)throw Error("Callback must be a function.");switch(t){case"init":this._onInit=i;break;case"sync":this._onSync=i}}async _loadLyric(t){try{const i=await fetch(t);return await i.text()}catch(t){throw Error("Failed to load lrc file: "+t.message)}}_findLineIndex(t){const i=[];if(this._data.forEach((e=>{const n=t-e.time;n>=0&&i.push(n)})),0==i.length)return null;const e=Math.min.apply(Math,i);return i.indexOf(e)}_parseLyric(t){const i=/\[((?:al|ar|au|by|re|ti|ve|length|offset):.+)\]/i,e=/\[(\d+:\d+(?:\.\d+))\](.*)/,n=t.split("\n");if(0==n.length)throw Error("Lyric is empty.");n.forEach((t=>{const n=t.match(i),s=t.match(e);if(n){const t=n[1].match(/(\w+):(.*)/),i=t[1],e=t[2];this._info[i]=e}if(s){const t=this._parseTime(s[1]),i=s[2]||"";this._data.push({time:t,text:i})}}))}_parseTime(t){const i=t.split(":"),e=60*parseInt(i[0]),n=parseFloat(i[1]);return parseFloat((e+n).toFixed(2))}}},"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t="undefined"!=typeof globalThis?globalThis:t||self).Liricle=i();
